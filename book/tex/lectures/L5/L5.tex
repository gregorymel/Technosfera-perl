\setcounter{chapter}{4}
\chapter{Общение с внешним миром}
Эта лекция посвящена работе с файлами, которые могут находиться как на локальном компьютере, так и на удаленном, работе с другими процессами (для каждого отдельного процесса все остальные являются внешним миром) и так далее.

\section{Работа с файлами}
\subsection{Открытие текстовых файлов}
Работа с файлами в языке perl является практически прямым binding'ом библиотеки из Си и, как следствие, происходит похожим образом. В отличие от Си, где работа с файлами происходит непосредственно с файловыми дескрипторами, в perl существует особый тип FILEHANDLE (<<файловый манипулятор>>), который представляет возможность работы с файлами и работает с файловыми дескрипторами внутри себя.

При запуске Perl открываются 3 файловых манипулятора (для работы со стандартными потоками ввода вывода), которые прямо внутри языка называются следующими BAREWORD'ами:
\begin{description}
  \item[STDIN] --- для работы со стандартным вводом
  \item[STDOUT] --- для работы со стандартным выводом
  \item[STDERR] --- для работы с потоком для вывода диагностических и отладочных сообщений
\end{description}
Сейчас эти BAREWORD'ы остались только для обратной совместимости. Правилом хорошего тона сейчас является использование обычных переменных (например \verb|my $fh|) для хранения файловых манипуляторов, которые можно передавать в функции, которые работают с файлами (например, open или readline).

Ошибка при открытии файла с помощью \verb|open| не является фатальной и не вызывает исключений: чтобы проверить, удалось ли открыть файл, необходимо смотреть на возвращаемое функцией \verb|open| значение. Если открытие файла прошло успешно, возвращается истина (единица), если же нет --- ложь (пустая строка). Поэтому часто используется конструкция \verb|open or die|, при исполнении которой в случае невозможности открыть файл вызывается исключение:
\begin{minted}{perl}
open(my $fh, "<", "input.txt")
  or die "Can't open < input.txt: $!";
\end{minted}
Функция \verb|close| используется тогда, когда файловый манипулятор не нужен и его можно закрыть. Теоретически, perl сам закрывает все файловые манипуляторы при завершении программы. Однако некоторые программы работают очень долго, а значит нужно внимательно следить, чтобы ненужные файлы были закрыты. Это, в частности обусловлено тем, что существуют ограничения со стороны операционной системы на количество одновременно открытых файлов.

В perl существуют следующие режимы работы с файлами:
\begin{itemize}[nosep]
  \item Режим чтения (\verb|<|) позволяет только прочитать содержимое файла.
  \item Режим записи (\verb|>|) стирает содержимое файла и открывает файл на запись.
  \item Режим дозаписи (\verb|>>|) позволяет дописать в конец файла.
  \item Режим записи и чтения (\verb|+>|) стирает содержимое файла, позволяет писать в него и читать то, что в этот файл было записано.
  \item Режим чтения и записи (\verb|+<|) не затирает его содержимое, ставит указатель на начало файла (если сразу начать что-то писать, то новая информация затрет существующие данные), позволяет перемещать указатель, записывать и считывать данные.
\end{itemize}
Каждый режим подходит для своей ситуации и их не стоит путать, чтобы избежать ошибок и не потерять важные данные. Эти режимы есть отражение режимов работы с файлами у функции \verb|fopen| в СИ (\verb|r,r+,w,w+,a|).

При открытии файла в perl можно указать кодировку, в которой записан этот файл, и в этом случае perl будет на лету делать необходимые преобразования. Это позволяет считывать файл не побайтово, а посимвольно, что удобно при работе с текстовыми данными. Также правильное указание кодировки необходимо для нормальной работы регулярных выражений, сравнений и сортировки, так как получившейся строке будет сразу выставлен utf-флаг.

Простейший пример перекодировки файла из CP-1251 в UTF-8:
\begin{minted}{perl}
open(my $fh_cp,'<:encoding(CP-1251)','cp1251.txt');
open(my $fh_utf, '>:encoding(UTF-8)', 'utf8.txt');
while( <$fh_cp> ){
    print $fh_utf $_;
}
close($fh_utf);
close($fh_cp);
\end{minted}

\subsection{Чтение и запись текстовых файлов}
Чтение из файлового манипулятора происходит с помощью оператора <<ромбик>> $<>$:
\begin{minted}{perl}
$input= <>
$line = <$handle>
@lines = <$handle>
\end{minted}
Если между угловыми скобками не указано имя файлового манипулятора, чтение будет производиться из стандартного ввода. При чтении файла в скалярном контексте оператор <<ромбик>> возвращает одну строку файла, а при чтении в списковом контексте --- массив из всех строк. Возможностью считывать массив из всех строк файла нужно пользоваться очень аккуратно, так как открытие большого или очень большого файла может привести к нехватке памяти и краху программы.

Запись и файловый манипулятор делается с помощью \verb|print|:
\begin{minted}{perl}
print $var;
print $fh $var;
\end{minted}
Если файловый манипулятор не указан в качестве первого аргумента \verb|print|, запись идет в стандартный вывод. Также \verb|print| поддерживает передачу BAREWORD в качестве файлового манипулятора:
\begin{minted}{perl}
print STDERR $var;
\end{minted}
В том числе, если BAREWORD был объявлен файловым манипулятором с помощью функции \verb|open|. Этот синтаксис поддерживается только в целях обратной совместимости, встречается в старых модулях и не должен быть использован при наприсании нового кода.

\subsection{Сохранение данных непосредственно в файле модуля}
Данные можно сохранять непосредственно в файле .pm модуля:
\begin{minted}{perl}
package mypkg;

sub read_my_data {
    my @lines = <DATA>;
    return \@lines;
}

1;
__DATA__
This is data from pm file
\end{minted}
В этом случае интерпретатор perl будет интерпретировать как код на perl только часть до конструкции \verb|__DATA__ |. Содержимое после этой конструкции будет доступно как файловый манипулятор \verb|DATA|:
\begin{minted}{perl}
my $line = <DATA>
\end{minted}
Стоит отметить, что вызывать \verb|open| не нужно.

Сохранять данные вместе с кодом часто бывает нужно при написании шаблонизаторов. Например, если нужно сгенерировать письмо пользователям по шаблону, его, чтобы не держать отдельный файл и/или не потерять его, можно как раз хранить в DATA.

\subsection{Чтение и запись бинарных файлов}
Бинарные файлы используются часто в тех случаях, когда текстовые данные занимают много места. Чтобы указать, что из файлового манипулятора необходимо читать по байтам, нужно выполнить:
\begin{minted}{perl}
binmode($fh);  # open with :raw      # для работы с двоичными данными
\end{minted}
Для работы с бинарными файлами perl предоставляет следующие возможности:
\begin{minted}{perl}
syswrite($fh, $data, length($data)); # небуферизированная запись
sysread($fh, $data, $data_size);     # прямой вызов системного read
read($fh, $data, $data_size);        # чтение двоичных данных
eof($fh);                            # проверка на отсутствие данных
\end{minted}
Важно отметить, что \verb|syswrite| и \verb|sysread| это небуферизированные запись и чтение, а команда \verb|read| обращается к определенному модулю perl, который сам решает, сколько нужно прочитать у операционной системы, какую часть выдать, а какую оставить в буфере (этот буфер находится внутри perl). Поэтому полностью быть увереным, что запись или чтение были выполнены полностью (все данные записаны и все считаны) можно только, если использовались прямые системные вызовы \verb|syswrite| и \verb|sysread|.

Пример, демонстрирующий работу с бинарными данными:
\begin{minted}{perl}
use strict;
use Digest::MD5 qw/md5_hex/;

$\ = "\n";
my $data = '';
my $data_size = 1024; # Размер записи в файле

open(my $fh, '<:raw', 'data.bin') or die $!;

while(!eof($fh)){
    read($fh, $data, $data_size) == $data_size
        or die("Неверный размер");
    print md5_hex($data);
}

close($fh);
\end{minted}
Здесь показано, как сразу открыть файл в бинарном режиме. Эта программа последовательно читает записи из бинарного файла (размер каждой записи составляет 1 килобайт) и выводит контрольную сумму MD5 для прочитанного фрагмента. Если размер файла неверный, программа сообщает об этом и прекращает работу.

При работе с файлом в бинарном режиме доступен произвольный доступ к файлу, то есть не обязательно прочитывать весь файл, если известно где хранятся нужные данные. Это очень часто используется, когда размер каждой записи в файле фиксирован, так как позволяет быстро переходить к нужной. Каждый раз, когда что-то прочитано из файла, операционная система запоминает, в каком месте остановилось чтение из этого файла. В perl доступны следующие команды для обеспечения произвольного доступа:
\begin{minted}{perl}
seek( $fh, $len, $type);   # позиционирование
tell($fh);                 # текущая позиция
\end{minted}
Команда \verb|seek| перемещает курсор на \verb|$len| в файловом манипуляторе \verb|$fh| от начала файла (если \verb|$type| равен 0), текущей позиции (если \verb|$type| равен 1) или его конца (если \verb|$type| равен 2).

Команда \verb|tell| возвращает текущую позицию курсора (в байтах) для данного файлового манипулятора. Если ее сохранить, то позже можно будет вернуться в это же место файла с помощью \verb|tell|.

\subsection{Операции проверки файлов}
Существуют операторы, которые позволяют проверять, можно ли открыть файл, записать в него и так далее. Считается хорошим тоном всегда проверять, может ли файл быть открыт до вызова команды \verb|open|. Это связано с тем, что в perl очень ограниченно поддерживаются исключения и недоступна обработка исключений. Операторы проверки файлов начинаются с дефиса (что может сбивать с толку), а за самим оператором следует файловый манипулятор:
\begin{verbatim}[nosep]
  -r  Файл доступен для чтения текущему пользователю
  -w  Файл доступен для записи текущему пользователю
  -x  Файл доступен для выполнения текущим пользователем
  -o  Файл принадлежит текущему пользователю

  -e  Файл существует
  -z  Файл пуст (имеет нулевой размер)
  -s  Файл непуст (возвращает размер в байтах)

  -f  Файл является простым файлом
  -d  Файл является папкой
  -l  Файл является символической ссылкой (всегда false,
            если не поддерживается файловой системой)
  -p  Файл является именованным каналом (FIFO)
  -S  Файл является сокетом.
\end{verbatim}
Обычно они используются следующим образом:
\begin{minted}{perl}
my $fname = 'file.txt';
my $fh;
open($fh, '<', $fname) if
    -e $fname and -f $fname and
    -r $fname and !-z $fname;
\end{minted}
Писать в этом случае \verb|or die| имеет смысл только, если были сделаны не все проверки (если все проверки были сделаны, \verb|or die| не выполнится никогда). Более того \verb|open| внутри себя делает все проверки, кроме проверки длины файла. К слову, проверку длины файла можно использовать, чтобы выдать пользователю информативное сообщение об ошибке, если открытый для чтения файл имеет нулевую длину.

\subsection{Работа с файловой системой}
Существуют следующие команды для работы с файлами:
\begin{verbatim}
  rename     Команда для переименования файла
  unlink     Команда для удаление файла
  truncate   Команда для очистка файла
  stat       Команда для получения информация о времени доступе к файлу
  utime      Команда для модификации информация о времени доступе к файлу
             (поведение команды utime зависит от используемой ОС)
\end{verbatim}

Существуют следующие команды для работы с директориями:
\begin{minted}{perl}
mkdir 'dir_name',   0755; # Создание директории
rmdir 'dir_name';         # Удалении директории
chdir 'dir_name';         # Измерение текущего рабочего каталога
\end{minted}
По умолчанию рабочим каталогом становится каталог, откуда был запущен бинарный файл perl. Если требуется написать приложение, поведение которого не зависит от места запуска, есть два варианта. Первый вариант --- всегда использовать полные пути, но такой вариант не всегда является подходящим, так как полные пути зависят от того, как была сконфигурирована операционная система. Поэтому лучшим вариантом будет определять положение бинарного файла приложения, а после устанавливать корневой каталог относительно него.

Удобный способ создать группу директорий, которых нет в файловой системе, это использовать \verb|make_path|:
\begin{minted}{perl}
use File::Path qw/make_path/;
make_path( '/full/path/to/dir',
    owner => 'user',
    group => 'group',
    mode => 0755);
\end{minted}
Функция \verb|make_path| может принимать широкий набор параметров.

Для чтения и работы с директориями существуют команды, аналогичные файловым командам:
\begin{verbatim}
  opendir    Открыть указанную папку
  readdir    Последовательно читать файлы в папке
  teldir     Сообщить текущую позицию внутри каталога
  seekdir    Перейти на заданную позицию в каталоге
  closedir   Завершить работу с этой папкой
\end{verbatim}
В качестве примера можно привести следующий код:
\begin{minted}{perl}
opendir(my $dh, 'path_to_dir') or die $!;

my $pos;

while(my $fname = readdir $dh){
    print $fname;
    $pos = telldir $dh if $fname = 'data.bin';
}

if ($pos){
    seekdir($dh, $pos);
    while(my $fname = readdir $dh){
        print "Second iter: $fname";
    }
}

closedir($dh);
\end{minted}


\section{Perl I/O backend} % 36:08
\subsection{Perl I/O}
В perl используются файловые манипуляторы, а не файловые дескрипторы (которые предоставляет непосредственно операционная система), поскольку в нем реализована система ввода-вывода perlio с поддержкой слоев.
Существуют, например, следующие слои:
\begin{verbatim}
  :unix      использование pread/pwrite
  :stdio     использование fread, fwrite, fseek/ftell
  :perlio    перл буфер для быстрого доступа к данным после чтения
             и минимизации копирования (readline/<>)
  :crlf      преобразование перевода строки в формат данной ОС
  :utf8      работа в UTF-8
  :encoding  перекодировка содержимого файла
  :bytes     работа с однобайтовыми кодировками
  :raw       binmode()
  :pop       псевдослой, который позволяет убрать из цепочки верхний слой
\end{verbatim}


\subsection{Буферизация ввода-вывода в Perl I/O}
Такая система была встроена в perl по причине того, что он является консольным языком. Часто было необходимо прочитывать последовательно из файла небольшие фрагменты. Использовать для этого системные вызовы неразумно, так как система всегда читает по блокам (например по 1кб), а затем выделяет из блока требуемый фрагмент. В итоге один и тот же блок был бы многократно прочитан, что сильно бы сказывалось на производительности. Система perlio включает в себя слой-буфер \verb|:perlio|, который делает следующее: при первом запросе фрагмента какого-либо блока слоем делается системный вызов на чтение всего блока, слой передает нужный фрагмент, а блок --- буферизуется. При последующих запросах фрагментов из этого же блока, системный вызов уже не производится, а возвращается значение из буфера.

Чтобы продемонстрировать выигрыш производительности от использования такой системы ввода вывода, можно провести тестирование производительности с помощью следующей программы:
\begin{minted}{perl}
use strict;
use PerlIO;
use Time::HiRes qw/gettimeofday/;

my $i=0;
my $start_time = gettimeofday();

while(<>){$i++}

print "Layers: ".join(',', PerlIO::get_layers(STDIN)).'; ';
print "lines: $i; time: ".(gettimeofday() - $start_time).$/;
\end{minted}
Тестирование на файле из почти трех миллиона строк дало следующий результат:
\begin{verbatim}
Layers: unix,perlio; lines: 2932894; time: 0.410083055496216
Layers: stdio; lines: 2932894; time: 3.00101494789124
Layers: unix; lines: 2932894; time: 33.2629461288452
\end{verbatim}
При использовании системы perlio буферизация происходит на уровне perlio и время чтения всех строк составило половину секунды. При использовании stdio буферизация происходит на уровне библиотеки языка Си (поскольку буферизация в Си не учитывает размер блока) и результат несколько хуже --- 3 секунды. Без использования буферизации результат составил 33 секунды.

\subsection{Подключение слоя из внешних библиотек}
Слой \verb|:via| представляет собой универсальный интерфейс, предоставляющий возможность подключения слоя из внешних библиотек. Например, \verb|PerlIO::via::gzip|, позволяет работать с архивами, архивируя и разархивируя данные на лету:
\begin{minted}{perl}
open( $cfh, ">:via(gzip)", 'stdout.gz' );
print $cfh @stuff;

open( $fh, "<:via(gzip)", "stuff.gz" );
while (<$fh>) {
...
}
\end{minted}
На CPAN представлено множеством слоев, которые можно подключить через \verb|:via|, в том числе реализующие временные файлы в оперативной памяти, а также слои, позволяющие автоматически парсить JSON или XML, и так далее. Безусловно, существует возможность самостоятельно написать новый слой, если потребуется.

\section{Взаимодействие процессов.} %19 46:21
При написании параллельных приложений важно обеспечить эффективное взаимодействие между процессами. Процессы могут обмениваться данными и информацией о состоянии.

\subsection{Исполнение команды командной строки}
Простейший вид взаимодействия процессов --- исполнение команды терминала, которая поддерживается в данной операционной системе, и сохранение результата. Это можно сделать с помощью backticks-оператора (\verb|'...'|), функции \verb|system()| или \verb|open()|:
\begin{minted}{perl}
my $out = `ls -l`;               # Блокирующий вызов, возвращает содержимое STDOUT в виде одной большой строковой переменной.
my @out = `ls -l`;               # Блокирующий вызов, возвращает содержимое STDOUT в виде массива строк.
system('ls -l');                 # Блокирующий вызов, возвращает только код завершения
open(my $out, '-|', 'ls', '-l'); # Не-блокирующий вызов. Возвращает содержимое STDOUT через pipe. Данные доступны через файловый манипулятор $out.
\end{minted}
В списковом контексте backticks-оператор возвращает результат из STDOUT в виде массива строк.

\subsection{Вызовы fork и exec}
При написании программы, которая будет работать в несколько процессов, неудобно писать для каждого процесса свою отдельную программу. Удобнее в определенных местах программы добавить точки ветвления с помощью системного вызова fork, который создает дочерний процесс, который является практически полной, независимой копией родительского процесса.

Вызов fork является очень эффективным системным вызовом, так как операционной системе нужно только добавить запись в своих внутренних структурах о том, что появился еще один процесс, память процесса при этом не копируется. Независимость исполнения обеспечивается механизмом copy-on-write: как только в одном из процессов модифицируется какой-нибудь общий блок памяти, он сначала копируется, чтобы память другого процесса в результате не изменилась.

Другая функция exec подменяет текущий процесс каким-то другим процессом. Эта операция тоже эффективная, так как операционной системе не нужно модифицировать свою таблицу процессов, очищать старую память процесса и заводить новую. Эта функция часто используется для создания инсталляторов на perl, которые после сбора параметров от пользователя <<превращаются>> в процесс разархивирования с нужными параметрами.

Поскольку дочерний и родительский процессы после fork выполняются независимо, то они и не взаимодействуют друг с другом. Взаимодействие процессов можно организовать с помощью \verb|pipe|. В результате организуется односторонний буфер так, что один процесс сможет в него только писать, а второй --- из этого же манипулятора что-то вычитать. Пример, как можно создать pipe между двумя процессами:
\begin{minted}{perl}
use strict;
use POSIX qw(:sys_wait_h);
$|=1;

my ($r, $w);
pipe($r, $w);
if(my $pid = fork()){
    close($r);
    print $w $_ for 1..5;
    close($w);
    waitpid($pid, 0);
}
else {
    die "Cannot fork $!" unless defined $pid;
    close($w);
    while(<$r>){ print $_ }
    close($r);
    exit;
}
\end{minted}
При выполнении системного вызова \verb|fork|, в родительском процессе в качестве результата его выполнения возвращается pid дочернего процесса, а в дочернем --- 0. Если операция не прошла успешно, возвращается значение undef. Команда \verb|waitpid| позволяет ждать, пока будет закончено выполнение другого процесса.

\subsection{Обработка сигналов. Уборка процессов-зомби}
Зомби --- процесс, который завершился, но код его завершения не был вычитан. Такой процесс висит в списке процессов операционной системы с пометкой <<z>>. Это сделано для того, чтобы не потерять информацию о коде завершения, если процесс, для которого предназначена эта информация, не может в данный момент ее прочитать.

Чтобы зомби не было, необходимо всегда определять параметр \verb|SIG{CHLD}|:
\begin{minted}{perl}
$SIG{CHLD} = sub {
  while( my $pid = waitpid(-1, WNOHANG)){

    last if $pid == -1;

    if( WIFEXITED($?) ){
      my $status = $? >> 8;
      print "$pid exit with status $status $/";
    }
    else {  print "Process $pid sleep $/"  }
  }
};
\end{minted}
Здесь \verb|WIFEXITED| --- истина, если процесс завершился, \verb|WEXITSTATUS| будет содержать код возврата (если \verb|WIFEXITED| --- истина). Если же процесс был только остановлен, то \verb|WIFSIGNALED| --- истина, а \verb|WTERMSIG| будет содержать номер сигнала, остановившего процесс. В данном примере функции \verb|waitpid| в качестве первого аргумента было передано \verb|-1|, а значит \verb|waitpid| сработает на любой дочерний процесс. Если в качестве второго параметра передано 0, то \verb|waitpid| будет блокирующим вызовом, а если \verb|WNOHANG| --- то нет.

Можно также перехватывать и другие сигналы, а не только \verb|$SIG{CHLD}|, напримере \verb|$SIG{INT}| (сигнал прерывания) или \verb|$SIG{ALRM}|. В частости, чтобы программа не реагировала на сочетание клавиш \verb|ctrl+C|, нужно написать:
\begin{minted}{perl}
$SIG{INT} = 'IGNORE';
\end{minted}
В этом случае программа никак не будет реагировать на это сочетание клавиш. Чтобы вывести сообщение можно поставить не \verb|'IGNORE'|, а передать ссылку на функцию, которая выводит сообщение пользователю (например, что программу не стоит резко завершать из-за возможности потери данных). Вернуть стандартное поведение можно так (например, если никакие опасные операции не выполняются):
\begin{minted}{perl}
$SIG{INT} = 'DEFAULT';
\end{minted}
После этого программа по сочетанию клавиш \verb|ctrl+C| просто завершится.

В любом месте программы можно завести будильник (один на всю программу). Если этот будильник сработал, от операционной системы приходит сигнал \verb|$SIG{ALRM}|. Например:
\begin{minted}{perl}
use Fcntl ':flock';
$SIG{ALRM} = sub {die "Timeout"};

alarm(10);

eval {
    flock(FH, LOCK_EX) or die "can't flock: $!";
};

alarm(0);
\end{minted}
Здесь программа заводит будильник на 10 секунд, после чего пытается получить lock на файл (это блокирующая операция). Если она получает lock, будильник выключается. В ином случае, после 10 секунд ожидания, программа завершается.

\subsection{Дополнительные модули}
Дополнительные модули для обеспечения взаимодействия процессов (подробнее см. документацию на CPAN):
\begin{itemize}
  \item Модули \verb|IPC::Open3| и \verb|IPC::Run3| позволяют вызвать программу (блокирующая операция) и перехватить все три файловых манипулятора:
  \begin{minted}{perl}
  my($wtr, $rdr, $err);
  $pid = open3($wtr, $rdr, $err, 'cmd', 'arg', ...);
  \end{minted}
  В результате будет порожден новый процесс, в котором будет исполнена требуемая команда с заданными аргументами. На стандартный вход будет подано содержимое \verb|$wtr|, а стандартный вывод и диагностические сообщения, полученные в результате выполнения команды, будут записаны в \verb|$rdr| и \verb|$err|.
  \item IO::Handle
\end{itemize}

Также бывает удобным создать именованный канал:
\begin{minted}{perl}
% mkfifo /path/named.pipe
\end{minted}
Этот именованный канал будет фактически файлом в файловой иерархии и может быть найден с помощью любого файлового менеджера. Получить доступ к нему из perl можно в любой момент после создания:
\begin{minted}{perl}
open( my $fifo, '<', '/path/named.pipe' );
while(<$fifo>){
    print "Got: $_";
}
close($fifo);
\end{minted}


\section{Работа с сокетами}
\subsection{Socket}
Работа с сокетами реализована посредством модуля Socket, который является простой привязкой к аналогичной библиотеке из языка Си (с точностью до имен функций):
\begin{minted}{perl}
use Socket; # include <socket.h>
\end{minted}
Следующим образом можно определить IP-адрес по известному url-адресу:
\begin{minted}{perl}
my $name = 'search.cpan.org';
my $addr_bin = gethostbyname($name);
my $ip = inet_ntoa($addr_bin);   # 194.106.223.155
\end{minted}
И в обратную сторону:
\begin{minted}{perl}
my $ip = '207.171.7.72';
my $addr_bin = inet_aton($ip);
my $name = gethostbyaddr($addr_bin, PF_INET);
                                 # mt.perl.org
\end{minted}
Для того, чтобы работать с сокетами на более высоком уровне, требуется использовать модуль \verb|IO::Socket|. Он предоставляет более <<перловый>> интерфейс для работы с сокетами, а также автоматически делает типовые действия.

Простейшее приложение-клиент, которое запрашивает страницу с сервера, имеет вид:
\begin{minted}{perl}
use strict;
use IO::Socket;
my $socket = IO::Socket::INET->new(
    PeerAddr => 'search.cpan.org',
    PeerPort => 80,
    Proto    => "tcp",
    Type     => SOCK_STREAM)
or die "Can`t connect to search.cpan.org $/";

print $socket
   "GET / HTTP/1.0\nHost: search.cpan.org\n\n";
my @answer = <$socket>;
print(join($/, @answer));
\end{minted}
Сокеты, в отличие от pipe, двунаправленные, то есть в сокет можно как писать, так и читать из него. Поэтому иногда для общения между процессами также имеет смысл использовать сокеты (например, по сети). В Unix-подобных ОС даже существуют unix-сокеты, представляющие собой именованные файлы.

Код программы-сервера несколько более громоздкий, так как необходимо предоставить множество параметров (подробнее см. в документации). Для примера приведен сервер-пингер:
\begin{minted}{perl}
use strict;
use IO::Socket;
my $server = IO::Socket::INET->new(
    LocalPort => 8081,
    Type      => SOCK_STREAM,
    ReuseAddr => 1,
    Listen    => 10)
or die "Can't create server on port 8081 : $@ $/";
while(my $client = $server->accept()){
    $client->autoflush(1);
    my $message = <$client>;
    chomp( $message );
    print $client "Echo: ".$message;
    close( $client );
    last if $message eq 'END';
}
close( $server );
\end{minted}
Команда \verb|accept| является блокирующей, ожидает подключения клиента, после чего возвращает соответствующий ему файловый манипулятор. Команда \verb|autoflush(1);| выключает любую буферизацию, что необходимо для корректной работы: при включенной буферизации небольшие сообщения от клиента будут <<висеть>> в буфере неопределенное время, пока буфер не будет заполнен. Команду \verb|autoflush(1);| не следует использовать только, если передача происходит большими фрагментами. Операция чтения сообщения от клиента является блокирующей до получения сообщения.


\subsection{Обработка нескольких соединений}
Основным недостатком предыдущего сервера является то, что к нему может подключиться максимум один клиент (после того, как accept был принят, сервер больше не ожидает подключений). Решить эту проблему можно с помощью команды \verb|fork|:
\begin{minted}{perl}
while(my $client = $server->accept()){
  my $child = fork();
  if($child){
    close ($client); next;
  }
  if(defined $child){
    close($server);
    my $other = getpeername($client);
    my ($err, $host, $service)=getnameinfo($other);
    print "Client $host:$service $/";
    $client->autoflush(1);
    my $message = <$client>;
    chomp( $message );
    print $client "Echo: ".$message;
    close( $client );
    exit;
  } else { die "Can't fork: $!"; }
}
\end{minted}
После принятия подключения от клиента, создается дочерний процесс, который общается с клиентом. Родительский процесс закрывает сокет для общения с клиентом и после этого ожидает новое подключение. Такая схема работы сервера, когда основной процесс только принимает подключения от новых клиентов и создает дочерние процессы для обслуживания их, лежит в основе большинства современных серверов.

Однако, если одновременно попросят подключения очень большое количество клиентов, будет создано соответствующее количество дочерних процессов. Количество дочерних процессоров ограничено и система может не позволить это сделать. Поэтому требуется сдедить за тем, чтобы количество активных подключений не превосходило количество подключений, которые можно обслужить в данный момент. Если количество активных подключений равно максимально допустимому, то пока их количество не уменьшится, новые подключения не должны приниматься.


\subsection{Определение имени и порта клиента}
При подключении нового клиента к серверу, строго говоря, неизвестно откуда пришел клиент, но в любом случае ему будет выданы данные. Если сервис не является общедоступным (например, внутрикорпоративный сервис, который выдает личные данные), то необходимо ограничить к нему доступ.

Определить имя и порт клиента можно с помощью следующего кода:
\begin{minted}{perl}
use IO::Socket qw/getnameinfo/;

my $other = getpeername($client);
my ($err, $host, $service) = getnameinfo($other);
print "New connection! from $host:$service $/";
\end{minted}
Функция \verb|getpeername| возвращает структуру:
\begin{minted}{c}
struct sockaddr_in {
    short          sin_family;
    unsigned short sin_port;
    struct in_addr sin_addr;
    char           sin_zero[8];
};
\end{minted}
В этой структуре содержится много информации. Для того, чтобы ограничить доступ к сервису корпоративной сетью, сначала нужно проверить, какой IP адрес отдается и, более того, чтобы исключить сценарий, когда подключение идет со взломанного компьютера внутри сети, необходимо этот IP адрес обратно превратить в имя хоста и принимать подключение, если только имя хоста, которое пришло, совпадает с полученным по IP адресу,

\section{Сериализация} % 1:20
\subsection{Понятие сериализации} % 1:20
Сериализация --- превращение объекта в поток байтов, по которому может быть восстановлен исходный объект. Этот протокол (способ сериализации и десериализации) должен быть определен вне зависимости от того, где именно будет храниться получившийся поток байт.

\begin{figure}[H] \centering
  \begin{tikzpicture}[      align=center,   minimum width  = 2cm,
      object/.style={draw,  fill=yellow!10, minimum height = 1.0cm },
      stream/.style={draw,  fill=yellow!5,  minimum height = 0.6cm },
      memory/.style={draw,  fill=blue!15,   minimum height = 1.6cm },
          db/.style={draw,  fill=red!15,    minimum height = 1.0cm },  ]

    \begin{scope}[node distance=1.5cm]
      \node[object                   ] (in)    {OBJECT};
      \node[stream, right = of in    ] (in-b)  {\small STREAM\\ OF BYTES};
      \node[db,     right = of in-b  ] (DB)    {DB};
      \node[stream, right = of DB    ] (out-b) {\small STREAM\\ OF BYTES};
      \node[object, right = of out-b ] (out)   {OBJECT};
    \end{scope}

    \begin{scope}[node distance=0.6cm]
      \node[memory, above = of DB  ] (file) {FILE};
      \node[memory, below = of DB  ] (mem)  {MEMORY};
    \end{scope}

    \begin{scope}[line width=2.2pt,shorten >=2pt, shorten <=2pt,>=stealth ]
        \draw[->] (in)    -- (in-b) node[above=1.5cm, midway] {
          \huge Serialization   };
        \draw[->] (in-b)  edge (DB) edge (file) edge (mem);
        \draw[<-] (out-b) edge (DB) edge (file) edge (mem);
        \draw[->] (out-b) --  (out) node[above=1.5cm, midway] {
          \huge Deserialization };

    \end{scope}

  \end{tikzpicture}
\end{figure}

Сериализованный объект можно передать также в программу, написанную на другом языке программирования, где он также может быть десериализован.

\subsection{Сериализация pack} % 1:22
Сериализация посредством превращения в бинарные данные по шаблону подходит для использования в высоконагруженных приложениях. Например, значения элементов массива могут быть сериализованы в строку, где между любыми двумя значениями будет расположен разделитель. Такой способ сериализации позволяет экономить память, так как любой бинарный поток, как правило, не вносит лишних символов.

Если передавать те же данные в текстовом виде (например, используя data dumper), строка будет содержать также кавычки, запятые и так далее: такой протокол очень сложно расшифровать и он не экономит ни байты при передаче, ни процессорное время.

Для превращения перловых структур в байтовые строки и обратно существуют операции \verb|pack| и \verb|unpack| соответственно:
\begin{minted}{perl}
pack TEMPLATE, LIST
\end{minted}
Функция \verb|pack| в качестве первого параметра принимает шаблон, в который надо сжимать, а в качестве второго --- список элементов, который к этому шаблону нужно применить. Шаблон представляет последовательность из символов:
\begin{verbatim}
  a  ---   строка байт, дополняемая нулями
  A  ---   строка байт, дополняемая пробелами
  b  ---   Битовая строка (младший бит идет первым)
  с  ---   Однобайтовый символ со знаком
  d  ---   Значение с плавающей запятой, двойной точности
  f  ---   Значение с плавающей запятой, одинарной точности шаблона
  h  ---   Строка шестнадцатиричных значений (младшие разряды идут    первыми)
  i  ---   Целое со знаком
  l  ---   Целое со знаком типа long
  n  ---   Целое 16 бит big-endian
  v  ---   Целое 16 бит little-endian
\end{verbatim}
При написании шаблона нужно четко придерживаться протокола, о котором есть договоренности с принимающей стороной. Существуют специальный символ \verb|/|, а также символ \verb|*|, которые позволяют записать длину строки перед самой строкой:
\begin{minted}{perl}
pack "Ca* ", length("Test"), "Test";# "\04Test"

pack "C/a*", "Test";          # "\04Test"
pack "L/a*", "Test";          # "\04\00\00\00Test"
pack "w/a*", "Test";          # "\04Test"
\end{minted}
Если на принимающей стороне программа написана на более низкоуровневом языке (например, на Си), то считав длину строки может быть сразу выделен буфер нужного размера.

Чтобы освоиться с pack, нужна небольшая тренировка. Несколько примеров сериализации и десериализации:
\begin{minted}{perl}
pack "A5", "perl", "language";      # "perl "
pack "A5 A2 A3", "perl", "language";# "perl la   "

pack "H2", "31";                    # "1"
pack "B8", "00110001"               # "1"

pack "LLxLLx", 1, 2, 3, 4;
    # "\1\0\0\0 \2\0\0\0 \0 \3\0\0\0 \4\0\0\0 \0"

unpack "H*", pack "A*", "string";   # 737472696e67

unpack "(H2)*", pack "A*", "string";
    # (73,74,72,69,6e,67)
\end{minted}

\subsection{Сериализация JSON}  % 1:30
JSON --- компактный человекочитаемый протокол обмена данными, произошедший от JavaScript. Поскольку JavaScript очень быстро сериализует-десериализует JSON, для обмена данными между браузером и web-сервером обычно используется именно JSON.

Пример данных в формате JSON:
\begin{minted}{json}
{ "orderID": 12345,
  "shopperName": "Ваня Иванов",
  "shopperEmail": "ivanov@example.com",
  "contents": [
    {
      "productID": 34,
      "productName": "Супер товар",
      "quantity": 1
    },
    {
      "productID": 56,
      "productName": "Чудо товар",
      "quantity": 3
    }
  ],
  "orderCompleted": true
}
\end{minted}
Этот протокол обмена данных очень хорошо читается человеком, и поэтому очень полезен при отладке.

Кодировать в JSON и декодировать из JSON можно с помощью \verb|encode_json| и \verb|decode_json|. Пример декодирования JSON в перловую структуру:
\begin{minted}{perl}
use JSON::XS;
use DDP;
p JSON::XS::decode_json(
    '{"key_array":["val1", "val2", 3]}'
);
\end{minted}
Перловая структура будет иметь вид:
\begin{minted}{bash}
{"key_array":["val1","val2",3]}
\ {
    key_array   [
        [0] "val1",
        [1] "val2",
        [2] 3
    ]
}
\end{minted}
Так выглядит преобразование из перловой структуры обратно в JSON:
\begin{minted}{perl}
use strict;
use JSON::XS;
my $struct = {key1 => 3};
print "Value: ".$struct->{key1}.$/;        #  Value: 3
print JSON::XS::encode_json( $struct ).$/; #  {"key1":"3"}
\end{minted}


В JSON выделяют следующие структуры:
\begin{itemize}
  \item \textbf{Объект} (как хэшу в Perl)~--- неупорядоченное множество ключей и соответствующих им значений.
  \begin{figure}[H] \centering
\begin{tikzpicture}[grammar style,setSyntaxDiagramPoints]
  \draw (LBracket)--(LP)|-(UP)-|(RP)--(RBracket);
  \draw (L)|-(DW)node[operator] {,}-|(R)--cycle;
  \draw[|-|] (LEnd)--(LBracket) node[operator] {\{}     --
      			             (-2,0) node[value]    {string} --
                         (0,0)  node[operator] {:}      --
	                       (2,0)  node[value]    {value}  --
                     (RBracket) node[operator] {\}}     -- (REnd);
\end{tikzpicture}
\end{figure}
  \item \textbf{Массив} (список в Perl)~--- упорядоченное множество значений.
\begin{figure}[H] \centering
  \begin{tikzpicture}[grammar style,setSyntaxDiagramPoints]
   \draw (LBracket)--(LP)|-(UP)-|(RP)--(RBracket);
   \draw (L)|-(DW)node[operator] {,}-|(R)--cycle;
   \draw[|-|]
      (LEnd)--(LBracket) node[operator] {[}     --
                  (0,0)  node[value]    {value}  --
              (RBracket) node[operator] {]}     -- (REnd);
  \end{tikzpicture}
\end{figure}
  \item \textbf{Значение}~--- число, строка, массив, объект или же неспецифичные для perl переменные (true, false и null). Модуль \verb|JSON::XS| обычно значение \verb|undef| в JSON отображает как \verb|null|. Работа с \verb|true| и \verb|false| идет с помощью двух соответствующих констант, которые определены внутри \verb|JSON::XS|.
\begin{figure}[H] \centering
  \begin{tikzpicture}[grammar style,setSyntaxDiagramPoints]
  	\draw[|-|] (LEnd) --  (0,0) node[value] {string} --  (REnd);

    \foreach [count=\n] \label in {number,object,array}
   	  \draw (LEnd)--(LP)|-(0,-0.8*\n) node[value] {\label}-|(RP)--(REnd);

    \foreach [count=\n from 4] \label in {true,false,null}
   	  \draw (LEnd)--(LP)|-(0,-0.8*\n) node[exotic value]{\label}-|(RP)--(REnd);
  \end{tikzpicture}
\end{figure}
\end{itemize}

\subsection{Сериализация CBOR}  % 1:35
CBOR исторически связан с JSON, но в отличие от последнего, является бинарным форматом. За счет этого скорость работы с этим форматом может быть немного выше, чем при работе с JSON:
\begin{minted}{perl}
use CBOR::XS;
my $cbor = CBOR::XS::encode_cbor([12,20,30]);
my $hash = CBOR::XS::decode_cbor( $cbor );
\end{minted}
В CBOR поддерживается потоковая передача. Это значит, что строка может состоять из нескольких записанных друг за другом валидных данных в формате CBOR и все они будут успешно распакованы.
\begin{minted}{perl}
use CBOR::XS;
my $cbors = CBOR::XS::encode_cbor([12,20,30]);
$cbors   .= CBOR::XS::encode_cbor(
    ["val1","val2","val3"]
);
my @array = ();
my $cbor_obj = CBOR::XS->new();
while( length $cbors ){
  my($data, $len)=$cbor_obj->decode_prefix($cbors);
  substr $cbors, 0, $len, '';
  push @array, $data;
}
\end{minted}
Также в формате CBOR не тратится память на кавычки, скобки и так далее, а структура данных организуется с помощью спец-символов.

\subsection{Сериализация MSGPACK}
MSGPACK --- бинарный вид сериализации, в котором целые числа переводятся в двоичное представление (а следовательно небольшие числа занимают по байту).
\begin{minted}{perl}
use strict;
use Data::MessagePack;
my $mp = Data::MessagePack->new();
my $packed   = $mp->pack({a => 1, b => 2, c => 3});
my $hash = $mp->unpack($packed);
\end{minted}
\begin{table}[H]{ \renewcommand{\arraystretch}{1.4} \centering
  \begin{tabular}{|p{3cm}|p{3cm}|p{3cm}|}\hline
  \cellcolor{red!3}&    \cellcolor{red!3}
                        \textbf{JSON}     &   \cellcolor{red!3}
                                              \textbf{MessagePack}  \\ \hline
  \cellcolor{red!3}
  \textbf{null}    & \verb|null|          &\verb|c0|                \\ \hline
  \cellcolor{red!3}
  \textbf{Integer} & \verb|10|            &\verb|0a|                \\ \hline
  \cellcolor{red!3}
  \textbf{Array}   & \verb|[20]|          &\verb|91 14|             \\ \hline
  \cellcolor{red!3}
  \textbf{String}  & \verb|"30"|          &\verb|a2 '3' '0'|        \\ \hline
  \cellcolor{red!3}
  \textbf{Map}     & \verb|"{"40":null}"| &\verb|81 a1 '4' '0' c0|  \\ \hline
\end{tabular} }
\end{table}
\textbf{MessagePack} является достаточно компактным методом сериализации.


\subsection{Сериализация Storable}
Сериализатор Storable умеет сериализовать и десериализовать какие-то структуры непосредственно в файл. В этом файле появляются бинарные данные, который на данный момент в основном понятны только perl'у:
\begin{minted}{perl}
use Storable;
my %table = ( "key1" => "val" );
store \%table, 'file';
$hashref = retrieve('file');
\end{minted}
При необходимости можно восстановить структуру по сохраненным в файл данным:
\begin{minted}{perl}
use Storable qw/freeze thaw/;
my %table = ( "key1" => "val" );
my $serialized = freeze \%table;
my $hash = thaw( $serialized );
\end{minted}
Методы freeze и thaw позволяют сериализовать и десериализовать не в файл, а в скалярную переменную.

Особо нужно отметить, что Storable очень полезен при реализации работы с файлами-конфигами.

\subsection{Сериализация XML}
Один из самых распространенных форматов для обмена данными --- это формат XML, который отличается своей хорошей читаемостью. Размер XML файлов всегда очень большой (на больших структурах занимает на порядок больше места, чем JSON).
\begin{minted}{perl}
use XML::LibXML;
my $dom = XML::LibXML->load_xml(
    string => '<xml><test>1</test></xml>'
);
\end{minted}

Замечательной особенностью парсера XML является то, что они работают поточно.
% TODO В лекции сказано, что HTML --- подмножество XML, что не совсем так. (XHTML является валидным XML)
В этом случае парсер обрабатывает строку по чуть-чуть и, если встречает тег или данные, вызывает указанную следующим образом функцию:
\begin{minted}{perl}
use XML::Parser;
my $parser = XML::Parser->new(
    Handlers => {
        Start => sub{print "New tag"},
        End   => sub{print "End tag"},
        Char  => sub{print "Data"}
    });
$parser->parse('<xml><test>1</test></xml>');
\end{minted}

\subsection{Сравнение быстродействия}
Здесь приведено быстродействие (скорость раскодирования одной и той же структуры) для всех представленных выше форматов:
\begin{minted}{bash}
YAML           84/s
XML::Simple   800/s
Data::Dumper 2143/s
FreezeThaw   2635/s
YAML::Syck   4307/s
JSON::Syck   4654/s
Storable     9774/s
JSON::XS    41473/s
CBOR::XS    42369/s
\end{minted}
Самым быстрым является CBOR, формат, пришедший на смену JSON. JSON работает только лишь чуть-чуть медленнее. Storable проигрывает на порядок, так как он заточен на работу с файловой системой.

\subsection{Сериализация Storable}
Сериализатор Storable умеет сериализовать и десериализовать какие-то структуры непосредственно в файл. В этом файле появляются бинарные данные, который на данный момент в основном понятны только perl'у:
\begin{minted}{perl}
use Storable;
my %table = ( "key1" => "val" );
store \%table, 'file';
$hashref = retrieve('file');
\end{minted}
При необходимости можно восстановить структуру по сохраненным в файл данным:
\begin{minted}{perl}
use Storable qw/freeze thaw/;
my %table = ( "key1" => "val" );
my $serialized = freeze \%table;
my $hash = thaw( $serialized );
\end{minted}
Методы freeze и thaw позволяют сериализовать и десериализовать не в файл, а в скалярную переменную.

Особо нужно отметить, что Storable очень полезен при реализации работы с файлами-конфигами.

\subsection{Сериализация XML}
Один из самых распространенных форматов для обмена данными --- это формат XML, который отличается своей хорошей читаемостью. Размер XML файлов всегда очень большой (на больших структурах занимает на порядок больше места, чем JSON).
\begin{minted}{perl}
use XML::LibXML;
my $dom = XML::LibXML->load_xml(
    string => '<xml><test>1</test></xml>'
);
\end{minted}

Замечательной особенностью парсера XML является то, что они работают поточно.
% TODO В лекции сказано, что HTML --- подмножество XML, что не совсем так. (XHTML является валидным XML)
В этом случае парсер обрабатывает строку по чуть-чуть и, если встречает тег или данные, вызывает указанную следующим образом функцию:
\begin{minted}{perl}
use XML::Parser;
my $parser = XML::Parser->new(
    Handlers => {
        Start => sub{print "New tag"},
        End   => sub{print "End tag"},
        Char  => sub{print "Data"}
    });
$parser->parse('<xml><test>1</test></xml>');
\end{minted}

\subsection{Сравнение быстродействия}
Здесь приведено быстродействие (скорость раскодирования одной и той же структуры) для всех представленных выше форматов:
\begin{minted}{bash}
YAML           84/s
XML::Simple   800/s
Data::Dumper 2143/s
FreezeThaw   2635/s
YAML::Syck   4307/s
JSON::Syck   4654/s
Storable     9774/s
JSON::XS    41473/s
CBOR::XS    42369/s
\end{minted}
Самым быстрым является CBOR, формат, пришедший на смену JSON. JSON работает только лишь чуть-чуть медленнее. Storable проигрывает на порядок, так как он заточен на работу с файловой системой.

\section{Разбор входных параметров}
У каждой запускаемой программы могут быть флаги (не нужно указывать значение):
\begin{minted}{bash}
rm -rf
ls -l
\end{minted}
и параметры (значение указывать нужно, но может быть задано значение по умолчанию):
\begin{minted}{bash}
mkdir -m 755
perl -e ''
\end{minted}

Модуль Getopt::Long позволяет удобно работать с флагами и параметрами.
\begin{minted}{perl}
use Getopt::Long;

my $param;
GetOptions("example" => \$param);
\end{minted}

\begin{table}[H]{ \renewcommand{\arraystretch}{1.4} \centering
  \begin{tabular}{|p{7cm}|p{5cm}|}\hline
 {\bf Описание параметра/флага}   & {\bf Пример}             \\ \hline
    param                         & --param или отсутствует  \\ \hline
    param!                        & --param --noparam        \\ \hline
    param=s                       & --param=string           \\ \hline
    param:s                       & --param --param=string   \\ \hline
    param=i                       & --param=1                \\ \hline
    param:i                       & --param --param=1        \\ \hline
    param=f                       & --param=3.14             \\ \hline
    param:f                       & --param --param=3.14     \\ \hline
    param                         &  p=s                     \\ \hline
\end{tabular} }
\end{table}
Его использование выглядит примерно так:
\begin{minted}{perl}
use Getopt::Long;
use Pod::Usage;
my $param = {};
GetOptions($param, 'help|?', 'man', 'verbose')
	or pod2usage(2);
pod2usage(1) if $param->{help};
pod2usage(-exitval => 0, -verbose => 2)
	if $param->{man};

__END__

=head1 NAME

sample - Script with Getopt::Long

=head1 SYNOPSIS
sample [options] [file ...]
Options:
-help            brief help message
-verbose         verbosity mode

=head1 OPTIONS

=over 8

=item B<-help>

Print help message.

=item B<-verbose>

Verbosely processing

=back

=head1 DESCRIPTION

B<this program>
Programm do something

=cut
\end{minted}
Если в хэше \verb|$param| появился ключ \verb|help|, значит при запуске приложения был передан соответствующий флаг и так далее. В этом примере использована удобная Pod-разметка для сохранения документации прямо внутри файла модуля после \verb|__END__|. Для этого используется модуль Pod::Usage, который экспортирует метод pod2usage.

\section{Интерактивный режим}
Интерактивный режим --- режим работы консольного приложения, в котором приложение не отсоединено от терминала, а значит с помощью стандартного ввода-вывода можно спросить пользователя при необходимости. Проверить, активен ли интерактивный режим можно так:
\begin{minted}{perl}
use strict;

sub is_interactive {
    return -t STDIN && -t STDOUT;
}

my $do = 1;
while( is_interactive() && $do ){
    print "Tell me anything: ";
    my $line = <>;
    print "Echo: ".$line;
    $do = 0 if $line eq "bye$/";
}

print "Goodbye$/";
\end{minted}
Если приложение не может принять решение самостоятельно, а интерактивный режим уже недоступен, оно должно упасть, так как не сможет спросить пользователя о его предпочтениях.
